import { NextRequest, NextResponse } from 'next/server';import { sql } from '@vercel/postgres';import { addHeroAwards, getHeroAwards, mapDbHeroToHero } from '@/lib/db';import { Hero } from '@/types';export async function GET(request: NextRequest) {  try {    const searchParams = request.nextUrl.searchParams;    const region = searchParams.get('region');    const award = searchParams.get('award');    const rank = searchParams.get('rank');    const yearFrom = searchParams.get('yearFrom');    const yearTo = searchParams.get('yearTo');    const searchQuery = searchParams.get('searchQuery');    let query = 'SELECT DISTINCT h.* FROM heroes h';    const params: (string | number)[] = [];    let paramCount = 1;    let whereClause = '';    if (award) {      query += ' LEFT JOIN awards a ON h.id = a.hero_id';    }    if (region) {      whereClause += `${whereClause ? ' AND' : ' WHERE'} h.region ILIKE $${paramCount++}`;      params.push(`%${region}%`);    }    if (award) {      whereClause += `${whereClause ? ' AND' : ' WHERE'} a.name ILIKE $${paramCount++}`;      params.push(`%${award}%`);    }    if (rank) {      whereClause += `${whereClause ? ' AND' : ' WHERE'} h.rank ILIKE $${paramCount++}`;      params.push(`%${rank}%`);    }    if (searchQuery) {      whereClause += `${whereClause ? ' AND' : ' WHERE'} (h.name ILIKE $${paramCount} OR h.description ILIKE $${paramCount})`;      params.push(`%${searchQuery}%`);      paramCount++;    }    if (yearFrom) {      whereClause += `${whereClause ? ' AND' : ' WHERE'} (        CAST(SPLIT_PART(h.years, '-', 1) AS INTEGER) >= $${paramCount++} OR        (h.years LIKE '%-%' AND CAST(SPLIT_PART(h.years, '-', 2) AS INTEGER) >= $${paramCount++})      )`;      params.push(parseInt(yearFrom, 10));      params.push(parseInt(yearFrom, 10));    }    if (yearTo) {      whereClause += `${whereClause ? ' AND' : ' WHERE'} (        CAST(SPLIT_PART(h.years, '-', 1) AS INTEGER) <= $${paramCount++} OR        (h.years LIKE '%-%' AND CAST(SPLIT_PART(h.years, '-', 2) AS INTEGER) <= $${paramCount++})      )`;      params.push(parseInt(yearTo, 10));      params.push(parseInt(yearTo, 10));    }    query += whereClause + ' ORDER BY h.name';    const result = await sql.query(query, params);    const heroes = result.rows;    const heroesWithAwards: Hero[] = await Promise.all(      heroes.map(async (hero) => {        const awards = await getHeroAwards(hero.id);        return mapDbHeroToHero(hero, awards);      })    );    return NextResponse.json({       success: true,       data: heroesWithAwards     });  } catch (error) {    console.error('Ошибка при получении списка героев:', error);    return NextResponse.json(      { success: false, message: 'Произошла ошибка при получении данных' },      { status: 500 }    );  }}export async function POST(request: NextRequest) {  try {    const body = await request.json();    if (!body.name) {      return NextResponse.json(        { success: false, message: 'Имя героя обязательно' },        { status: 400 }      );    }    const result = await sql`      INSERT INTO heroes (name, rank, region, description, years, photo)      VALUES (${body.name}, ${body.rank || ''}, ${body.region || ''},               ${body.description || ''}, ${body.years || ''}, ${body.photo || ''})      RETURNING *;    `;    const newHero = result.rows[0];    if (body.awards && Array.isArray(body.awards) && body.awards.length > 0) {      await addHeroAwards(newHero.id, body.awards);    }    const awards = await getHeroAwards(newHero.id);    const heroWithAwards = mapDbHeroToHero(newHero, awards);    return NextResponse.json({       success: true,       data: heroWithAwards     }, { status: 201 });  } catch (error) {    console.error('Ошибка при добавлении героя:', error);    return NextResponse.json(      { success: false, message: 'Произошла ошибка при добавлении данных' },      { status: 500 }    );  }} 